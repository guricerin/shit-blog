<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>『Clean Architecture 達人に学ぶソフトウェアの構造と設計』個人メモ - グリのクソブログ</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="『Clean Architecture 達人に学ぶソフトウェアの構造と設計』個人メモ" />
<meta property="og:description" content="本の内容をまとめただけになったので、著作権的にまずい場合、まとめ部分を削除するかこの記事丸ごと削除します。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guricerin.github.io/shit-blog/private-memo/20210916-clean-arch/" />
<meta property="article:published_time" content="2021-09-16T09:37:18+09:00" />
<meta property="article:modified_time" content="2021-09-16T09:37:18+09:00" />

		<meta itemprop="name" content="『Clean Architecture 達人に学ぶソフトウェアの構造と設計』個人メモ">
<meta itemprop="description" content="本の内容をまとめただけになったので、著作権的にまずい場合、まとめ部分を削除するかこの記事丸ごと削除します。">
<meta itemprop="datePublished" content="2021-09-16T09:37:18&#43;09:00" />
<meta itemprop="dateModified" content="2021-09-16T09:37:18&#43;09:00" />
<meta itemprop="wordCount" content="442">



<meta itemprop="keywords" content="" />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="『Clean Architecture 達人に学ぶソフトウェアの構造と設計』個人メモ"/>
<meta name="twitter:description" content="本の内容をまとめただけになったので、著作権的にまずい場合、まとめ部分を削除するかこの記事丸ごと削除します。"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="https://guricerin.github.io/shit-blog/css/style.css">
	<link rel="stylesheet" href="https://guricerin.github.io/shit-blog/css/custom.css">

	<link rel="shortcut icon" href="https://guricerin.github.io/shit-blog/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-109224463-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="https://guricerin.github.io/shit-blog/" title="グリのクソブログ" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="https://guricerin.github.io/shit-blog/img/icon.jpg">
				</div><div class="logo__item logo__text">
					<div class="logo__title">グリのクソブログ</div>
					<div class="logo__tagline">主にB&#39;z</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="https://guricerin.github.io/shit-blog/">
				
				<span class="menu__text">HOME</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="https://guricerin.github.io/shit-blog/privacy-policy">
				
				<span class="menu__text">PRIVACY POLICY</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="https://guricerin.github.io/shit-blog/feed.xml">
				
				<span class="menu__text">RSS</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">『Clean Architecture 達人に学ぶソフトウェアの構造と設計』個人メモ</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-16T09:37:18&#43;09:00">2021-09-16</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="https://guricerin.github.io/shit-blog/categories/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/" rel="category">プログラミング</a>, <a class="meta__link" href="https://guricerin.github.io/shit-blog/categories/%E6%9B%B8%E7%89%A9/" rel="category">書物</a>
	</span>
</div></div>
		</header>
		<div class="content post__content clearfix">
			<p>本の内容をまとめただけになったので、著作権的にまずい場合、まとめ部分を削除するかこの記事丸ごと削除します。</p>
<h3 id="目次">目次</h3>
<ol>
<li><a href="#a0">序文</a></li>
<li><a href="#a1">設計とアーキテクチャ</a></li>
<li><a href="#a2">2つの価値のお話</a></li>
<li><a href="#a3">パラダイムの概要</a></li>
<li><a href="#a4">構造化プログラミング</a></li>
<li><a href="#a5">オブジェクト指向プログラミング</a></li>
<li><a href="#a6">関数型プログラミング</a></li>
<li><a href="#a7">SRP：単一責任の原則</a></li>
<li><a href="#a8">OCP：オープン・クローズドの原則</a></li>
<li><a href="#a9">LSP：リスコフの置換原則</a></li>
<li><a href="#a10">ISP：インターフェイス分離の原則</a></li>
<li><a href="#a11">DIP：依存関係逆転の原則</a></li>
<li><a href="#a12">コンポーネント</a></li>
<li><a href="#a13">コンポーネントの凝集性</a></li>
<li><a href="#a14">コンポーネントの結合</a></li>
<li><a href="#a15">アーキテクチャとは？</a></li>
<li><a href="#a16">独立性</a></li>
<li><a href="#a17">バウンダリー：境界線を引く</a></li>
<li><a href="#a18">境界の解剖学</a></li>
<li><a href="#a19">方針とレベル</a></li>
<li><a href="#a20">ビジネスルール</a></li>
<li><a href="#a21">叫ぶアーキテクチャ</a></li>
<li><a href="#a22">クリーンアーキテクチャ</a></li>
<li><a href="#a23">プレゼンターとHumble Object</a></li>
<li><a href="#a24">部分的な境界</a></li>
<li><a href="#a25">レイヤーと境界</a></li>
<li><a href="#a26">メインコンポーネント</a></li>
<li><a href="#a27">サービス：あらゆる存在</a></li>
<li><a href="#a28">テスト境界</a></li>
<li><a href="#a29">クリーン組込みアーキテクチャ</a></li>
<li><a href="#a30">データベースは詳細</a></li>
<li><a href="#a31">ウェブは詳細</a></li>
<li><a href="#a32">フレームワークは詳細</a></li>
<li><a href="#a33">事例：動画販売サイト</a></li>
<li><a href="#a34">書き残したこと</a></li>
<li><a href="#a35">雑な感想</a></li>
</ol>
<hr>
<p><a id="a0"></a></p>
<h3 id="序文">序文</h3>
<ul>
<li>ソフトウェアの種類に関わらずアーキテクチャのルールはどれも同じ</li>
<li>プログラミングの要素は今も昔も「順次」「選択」「反復」と「間接参照」</li>
</ul>
<hr>
<p><a id="a1"></a></p>
<h3 id="1章--設計とアーキテクチャ">1章  設計とアーキテクチャ</h3>
<ul>
<li>「設計」と「アーキテクチャ」は同じ。
<ul>
<li>「アーキテクチャ」を抽象的な構造、「設計」を具体的な詳細、と区別することは無意味。ソフトウェアの構造は連続的だから。</li>
</ul>
</li>
<li>品質の良い設計は、システム改修やリリースのコストが少ないかで計測可能。</li>
<li>短絡的にシステム全体を再設計しても上手くいかない。</li>
</ul>
<hr>
<p><a id="a2"></a></p>
<h3 id="2章--2つの価値のお話">2章  2つの価値のお話</h3>
<ul>
<li>振る舞い
<ul>
<li>ソフトウェアの価値一つ目。 マシンに対してステークホルダーが望む機能。</li>
</ul>
</li>
<li>アーキテクチャ
<ul>
<li>ソフトウェアの価値二つ目。マシンの機能変更の容易性・柔軟性。</li>
<li>開発者はこちらを重視すべき。完璧に動作するが変更が事実上不可能なシステムはもはや「ソフト」ウェアではない。</li>
</ul>
</li>
<li>開発者もステークホルダー。システムの構造が破壊されないよう、他のステークホルダーと闘争するのが仕事。</li>
</ul>
<hr>
<p><a id="a3"></a></p>
<h3 id="3章--パラダイムの概要">3章  パラダイムの概要</h3>
<ul>
<li>構造化プログラミング
<ul>
<li>Edsger Wybe Dijkstra が1968年に発見。</li>
<li>制限のないジャンプに制限を加えた（goto文 -&gt; if文、while文）。</li>
</ul>
</li>
<li>オブジェクト指向プログラミング
<ul>
<li>Ole Johan Dahl, Kristen Nyagaard が1966年に発見。</li>
<li>関数ポインタに規律を加え、ポリモーフィズムの発見につながった。</li>
</ul>
</li>
<li>関数型プログラミング
<ul>
<li>Alonzo Church が1936年にラムダ計算を発明。John McCarthy が1958年に Lisp を開発。</li>
<li>変数の書き換えに制限を加えた。</li>
</ul>
</li>
<li>どのパラダイムもプログラミングに規律を加え、何をすべきでないかを伝えている。</li>
</ul>
<hr>
<p><a id="a4"></a></p>
<h3 id="4章--構造化プログラミング">4章  構造化プログラミング</h3>
<ul>
<li>goto文の制御によってプログラムのモジュールを再帰的に分割し、証明可能な小さな機能にできる。</li>
<li>テストはプログラムが正しくないことを証明できるが、正しいことは証明できない（反証性）。</li>
</ul>
<hr>
<p><a id="a5"></a></p>
<h3 id="5章--オブジェクト指向プログラミング">5章  オブジェクト指向プログラミング</h3>
<ul>
<li>オブジェクト指向とは
<ul>
<li>「データと関数の組み合わせ」？<code>o.f()</code>と<code>f(o)</code>は別物ではない。</li>
<li>「現実の世界をモデル化する方法」？意味不明。</li>
</ul>
</li>
<li>カプセル化
<ul>
<li>データ構造や関数の実装の、外側からの隠蔽。</li>
<li>C言語ではデータ構造と関数をヘッダーファイルに宣言し、その詳細は実装ファイルに書くことでカプセル化を実現。</li>
<li>後続のOO言語ではカプセル化はむしろ弱体化している。</li>
</ul>
</li>
<li>継承
<ul>
<li>スコープ内の変数と関数のグループを再宣言したもの。</li>
<li>C言語でも実現可能。後続の言語より手間ではあるが。</li>
</ul>
</li>
<li>ポリモーフィズム
<ul>
<li>関数ポインタの応用。関数の機能をデータ構造ごとに差し替えられる。</li>
<li>C言語とは違い、OO言語はポリモーフィズムを安全かつ便利に使用可能。</li>
<li>OO言語ではこれが重要。</li>
</ul>
</li>
<li>ソースコードの依存関係は制御の流れによって決まるが、ポリモーフィズムを利用したインターフェイスを挿入することで依存関係を逆転可能。
<ul>
<li>例 : UIやデータベースをビジネスルールのプラグインにできる。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a6"></a></p>
<h3 id="6章--関数型プログラミング">6章  関数型プログラミング</h3>
<ul>
<li>可変変数が存在しなければ、競合状態、デッドロック状態、並行更新の問題は発生しない。
<ul>
<li>ストレージとプロセッサ速度には限界があるので、実際は不変性をある程度妥協する。</li>
</ul>
</li>
<li>可変コンポーネントと普遍コンポーネントを分離。</li>
<li>可変変数はトランザクショナルメモリに配置するのが一般的。</li>
<li>イベントソーシング :
<ul>
<li>状態ではなく処理（トランザクション）を保存する戦略。</li>
<li>記録された処理から状態を計算。</li>
<li>例 : ソースコード管理システム</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a7"></a></p>
<h3 id="7章--srp単一責任の原則">7章  SRP：単一責任の原則</h3>
<ul>
<li>Single Responsibility Principle</li>
<li>「どのモジュールもたったひとつのことだけを行うべき」ということではない。
<ul>
<li>「ひとつの関数はひとつのことだけを行うべき」というのは最下位レベルの話。</li>
</ul>
</li>
<li>「モジュールはたったひとつのアクター（機能変更を望む人たちのグループ）に対して責任を負うべき」。
<ul>
<li>アクターの異なるコードは分割するべき。</li>
<li>例 : Employee型にアクターの異なるメソッド（calculatePay() : 経理部門、reportHours() : 人事部門、save() : データベース管理者）が含まれているのは、単一責任の原則に違反。</li>
<li>解決策 : GoFのFacadeパターンを用いる。Employee型からメソッドをそれぞれPayCalculator型、HourReporter型、EmployeeSaver型に切り出し、それら三つのデータ型に処理を委譲するだけのEmployeeFacade型を使用する。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a8"></a></p>
<h3 id="8章--ocpオープンクローズドの原則">8章  OCP：オープン・クローズドの原則</h3>
<ul>
<li>Open-Closed Principle</li>
<li>「ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき」。</li>
<li>コンポーネントAがコンポーネントBの変更から保護されるべきなら、コンポーネントBからコンポーネントAに依存させる。</li>
<li>ビジネスルールを含むコンポーネントは、アプリケーションの最上位レベルの方針を含む。他のどのコンポーネントにも依存するべきではない。</li>
<li>インターフェイスの役割 :
<ul>
<li>依存性逆転。</li>
<li>周辺コンポーネントが中心コンポーネントに依存しすぎないようにすること。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a9"></a></p>
<h3 id="9章--lspリスコフの置換原則">9章  LSP：リスコフの置換原則</h3>
<ul>
<li>Liskov Substitution Principle</li>
<li>オブジェクト指向の黎明期には、継承の使い方の方針になると考えられた。だが現在では、インターフェイスと実装に関する原則になっている。</li>
<li>リスコフの置換原則はデータ型に限らず、RESTfulなどアーキテクチャレベルにも適用可能。てか適用すべき。</li>
<li>リスコフの置換原則の違反例
<ul>
<li>正方形・長方形問題 : Square型はRectangle型の派生型とは言えない。Rectangle型は幅と高さを独立して変更できるのに対し、Square型は両方を同時に変更する必要がある。</li>
<li>RESTfulな配車サービスにおいて、タクシー会社ごとに異なるURIを用意する。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a10"></a></p>
<h3 id="10章--ispインターフェイス分離の原則">10章  ISP：インターフェイス分離の原則</h3>
<ul>
<li>Interface Segregation Principle</li>
<li>依存先のデータ型に欲しいメソッドを直接生やすのではなく、インターフェイスを間にかます。</li>
</ul>
<hr>
<p><a id="a11"></a></p>
<h3 id="11章--dip依存関係逆転の原則">11章  DIP：依存関係逆転の原則</h3>
<ul>
<li>Dependency Inversion Principle</li>
<li>依存性逆転を絶対視してはならない。OSやプラットフォーム、標準ライブラリへの依存は許容してもいい。</li>
<li>開発中のモジュール、頻繁に変更され続けているモジュールなど、システム内の変化しやすい要素に依存性逆転を適用すべし。</li>
<li>具象オブジェクトの生成には、GoFのAbstract Factoryパターンを用いる。</li>
<li>エントリーポイントは依存関係逆転の原則を満たし得ない。</li>
</ul>
<hr>
<p><a id="a12"></a></p>
<h3 id="12章--コンポーネント">12章  コンポーネント</h3>
<ul>
<li>コンポーネント : デプロイの単位。静的型付けならバイナリ、動的型付けならソースファイル。</li>
<li>CPUやメモリの飛躍的発展により、動的リンクの時代が訪れた。</li>
</ul>
<hr>
<p><a id="a13"></a></p>
<h3 id="13章--コンポーネントの凝集性">13章  コンポーネントの凝集性</h3>
<ul>
<li>再利用・リリース等価の原則
<ul>
<li>コンポーネントを形成するクラスやモジュールは凝集性のある（目的が一貫している）グループでなければならない。</li>
<li>同時に、まとめてリリース可能でなければならない。</li>
<li>コンポーネントを大きくする方向に働く。</li>
</ul>
</li>
<li>閉鎖性共通の原則
<ul>
<li>変更の理由が異なるクラスは別のコンポーネントに分ける。</li>
<li>二つのクラスが密結合しているなら、それらは同じコンポーネントに属させるべき。</li>
<li>コンポーネントを大きくする方向に働く。</li>
</ul>
</li>
<li>全再利用の原則
<ul>
<li>コンポーネントに依存するなら、そのコンポーネントに含まれる全てのクラスに依存させる。</li>
<li>コンポーネントを小さくする方向に働く。</li>
</ul>
</li>
<li>プロジェクトの段階によって、当てはまるコンポーネント構造は変化する。</li>
</ul>
<hr>
<p><a id="a14"></a></p>
<h3 id="14章--コンポーネントの結合">14章  コンポーネントの結合</h3>
<ul>
<li>非循環依存関係の原則
<ul>
<li>循環依存はいけない。コンポーネントの依存構造を有向非循環グラフにしなければ、コンポーネント分割のメリットが消滅する。</li>
<li>解決策 : 依存性逆転 or 新たなコンポーネントを切り出す。</li>
</ul>
</li>
<li>コンポーネント図はシステムの機能を表すのではなく、システムのビルド可能性や保守性を見るためのもの。</li>
<li>クラス設計の前にコンポーネントの依存構造を決めようとすると失敗する。</li>
<li>安定依存の原則
<ul>
<li>変更可能性の少ないコンポーネントに依存するべし。</li>
<li>すべてのコンポーネントを安定的にすべきということではない。変更可能なコンポーネントがなくなるから。</li>
</ul>
</li>
<li>安定度・抽象度等価の原則
<ul>
<li>安定的なコンポーネントは抽象的にする。不安定なコンポーネントは具体的にする。</li>
<li>抽象的なら拡張しやすく、具体的なら変更しやすい。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a15"></a></p>
<h3 id="15章--アーキテクチャとは">15章  アーキテクチャとは？</h3>
<ul>
<li>ソフトウェアアーキテクトはプログラマ。「プログラムしない」というのはデマ。</li>
<li>アーキテクチャ : システムの開発・デプロイ・運用・保守を容易にするための設計。いすれも軽視すべきではない。</li>
<li>開発チームの規模に左右されるアーキテクチャはデプロイ・運用・保守に最適ではない。</li>
<li>システムの方針 : ビジネスルールや手順。</li>
<li>システムの詳細 : IOデバイス、データベース、フレームワーク、通信プロトコルなど。</li>
<li>アーキテクトはシステムの詳細の決定を後回しにして選択肢を残しておくべし。</li>
</ul>
<hr>
<p><a id="a16"></a></p>
<h3 id="16章--独立性">16章  独立性</h3>
<ul>
<li>コードの重複を恐れてはならない。将来的にまったく違うデータ構造・アルゴリズムになりうるので。
<ul>
<li>例 : データベースのテーブル構造とUIのビューモデルは分けておく。</li>
</ul>
</li>
<li>システムの段階によってレイヤーの適切な切り離し方式は決まる。
<ul>
<li>ソースレベル : コンポーネント間の通信は、関数呼び出し。</li>
<li>デプロイレベル : 関数呼び出し、プロセス間通信、共有メモリなど。</li>
<li>サービスレベル : ネットワークパケット。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a17"></a></p>
<h3 id="17章--バウンダリー境界線を引く">17章  バウンダリー：境界線を引く</h3>
<ul>
<li>ビジネスルール、IO、データベースに境界線を引く。</li>
<li>境界線をまたがるのはインターフェイスとその実装のみにする。</li>
<li>システムの詳細（IO、データベースなど）がシステムの方針（ビジネスルール）に依存するようにする。
<ul>
<li>ビジネスルールにとってシステムの詳細がプラグイン化することになり、それらを取替可能。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a18"></a></p>
<h3 id="18章--境界の解剖学">18章  境界の解剖学</h3>
<ul>
<li>モジュールA（上位レベル）からモジュールB（下位レベル）制御が流れる場合、インターフェイスとデータ構造をモジュールAに定義し、モジュールBでインターフェイスを実装することで依存性を逆転可能。</li>
</ul>
<hr>
<p><a id="a19"></a></p>
<h3 id="19章--方針とレベル">19章  方針とレベル</h3>
<ul>
<li>レベル : システムの入力と出力からの距離。入力と出力（システムの詳細）から離れていれば、コンポーネントのレベルは高くなる（システムの方針）。</li>
<li>レベルが高いほど変更の頻度は低く、変更理由の重要性は高い。</li>
<li>暗号化プログラムの例 :
<ul>
<li>IOモジュールを低レベルに、コアの暗号アルゴリズムを高レベルに配置する。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a20"></a></p>
<h3 id="20章--ビジネスルール">20章  ビジネスルール</h3>
<ul>
<li>最重要ビジネスルール :
<ul>
<li>利益を生み出すルールや手続き。</li>
<li>システムが自動化されていなくとも存在する。</li>
</ul>
</li>
<li>最重要ビジネスデータ :
<ul>
<li>最重要ビジネスルールで制御するデータ。</li>
<li>システムが自動化されていなくとも存在する。</li>
</ul>
</li>
<li>エンティティ :
<ul>
<li>最重要ビジネスルールと最重要ビジネスデータ。それらを結びつけたオブジェクト。OO以外なら、それらを含むモジュール。</li>
<li>システムにおいて最上位のレベルに位置する。他のコンポーネントに依存しない。</li>
</ul>
</li>
<li>ユースケース :
<ul>
<li>自動化されたシステムを使用する方法。入出力データの処理など。</li>
<li>アプリケーション固有のビジネスルール。</li>
<li>エンティティを制御する。</li>
<li>UIや通信方法には依存しない。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a21"></a></p>
<h3 id="21章--叫ぶアーキテクチャ">21章  叫ぶアーキテクチャ</h3>
<ul>
<li>アーキテクチャはシステムのユースケースを支える構造。フレームワークに従うものではない。</li>
<li>エンティティとユースケースはユニットテスト可能でなければならない。</li>
<li>ユースケースのコードを見ればどのようなシステムか分かるようにすべき。</li>
</ul>
<hr>
<p><a id="a22"></a></p>
<h3 id="22章--クリーンアーキテクチャ">22章  クリーンアーキテクチャ</h3>
<ul>
<li>素晴らしいアーキテクチャの共通点 :
<ul>
<li>ソフトウェアをレイヤー分割し、関心事を分離している。</li>
<li>少なくとも、ビジネスルールのレイヤーとUIのレイヤーを持つ。</li>
</ul>
</li>
<li>ソースコードの依存性の方向は、レイヤーの内側（上位レベルの方針）だけに向かっていなければいけない。</li>
<li>エンティティのレイヤーは変化する可能性が低い。</li>
<li>システムの操作の変更が、ユースケースのレイヤーに影響することもある。</li>
<li>インターフェイスアダプター :
<ul>
<li>エンティティ、ユースケースのデータと、IOやデータベースのデータ間の変換を行うレイヤー。</li>
<li>例 : MVC</li>
</ul>
</li>
<li>フレームワークとドライバ :
<ul>
<li>最も外側のレイヤー。</li>
<li>このレイヤーでコードを書くことは少ない。</li>
</ul>
</li>
<li>レイヤーはエンティティ、ユースケース、インターフェイスアダプター、フレームワークとドライバ、の4つだけということはない。減ってもいいし増えてもいい。</li>
<li>レイヤー間をまたがるデータ構造は、内側のレイヤーにとって便利な形式にすること。外側の形式にすると内側が外側を知ることになり、依存性ルールに違反する。</li>
</ul>
<hr>
<p><a id="a23"></a></p>
<h3 id="23章--プレゼンターとhumble-object">23章  プレゼンターとHumble Object</h3>
<ul>
<li>Humble Objectパターン :
<ul>
<li>GoFではない。</li>
<li>テストしやすいモジュールとしにくいモジュールに分割し、後者をHumble（控えめ）にする。</li>
</ul>
</li>
<li>View :
<ul>
<li>UIそのもの。テストしにくい。</li>
<li>コードはできるだけ簡潔にする。</li>
</ul>
</li>
<li>Presenter :
<ul>
<li>テスト可能。</li>
<li>内側のレイヤーから受け取ったデータを適切な文字列に変換し、Viewから参照可能なViewModelに配置する。</li>
</ul>
</li>
<li>ORM（厳密にはデータマッパー）はデータベースのレイヤーに属する。</li>
<li>レイヤーの境界線上でHumble Objectパターンを用いるとテストしやすくなる。</li>
</ul>
<hr>
<p><a id="a24"></a></p>
<h3 id="24章--部分的な境界">24章  部分的な境界</h3>
<ul>
<li>だが、レイヤーを本格的に分けるのは面倒だしYAGNIな一面もある。</li>
<li>手抜き
<ul>
<li>複数のコンポーネント（デプロイの単位）を管理する必要がなくなる。</li>
<li>レイヤーの両側にインターフェイスを用意する必要がない。</li>
<li>後で完全な境界に発展させる余地を残す（逆にアーキテクチャが劣化する恐れもあり）。</li>
</ul>
</li>
<li>Strategyパターン :
<ul>
<li>レイヤの片側だけにインターフェイスを用意する。</li>
</ul>
</li>
<li>Facadeパターン :
<ul>
<li>依存性逆転すらしない。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a25"></a></p>
<h3 id="25章--レイヤーと境界">25章  レイヤーと境界</h3>
<ul>
<li>単純なシステムならユースケース、UI、データベースの3つのコンポーネントでこと足りる。</li>
<li>システムが複雑化するとコンポーネントは増える。</li>
<li>ていうか単純なシステムでも、しようと思えばいくらでもレイヤー分割できる。</li>
<li>アーキテクチャはレイヤー分割を実行するコストと無視するコストを評価し、何度も決定を下さなければならない。</li>
</ul>
<hr>
<p><a id="a26"></a></p>
<h3 id="26章--メインコンポーネント">26章  メインコンポーネント</h3>
<ul>
<li>Mainコンポーネント :
<ul>
<li>エントリーポイント。システムの最下位レベル。</li>
<li>システムの上位レベルに制御を渡す。</li>
<li>依存性注入はここで行う。</li>
<li>システムのプラグインとして捉えれば、開発用、テスト用、本番用のエントリーポイントを用意可能。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a27"></a></p>
<h3 id="27章--サービスあらゆる存在">27章  サービス：あらゆる存在</h3>
<ul>
<li>スケーラブル :
<ul>
<li>開発とデプロイの独立性が高いこと。</li>
<li>これが高いほどシステムの開発・保守・運用を分割可能。</li>
</ul>
</li>
<li>システムをサービスレベルで分割すると、再利用性はなくなる。</li>
<li>アーキテクチャにおいてサービスは重要ではない。</li>
</ul>
<hr>
<p><a id="a28"></a></p>
<h3 id="28章--テスト境界">28章  テスト境界</h3>
<ul>
<li>テストも依存性のルールに従う。</li>
<li>システムの一部として設計されていなければ、保守が難しいテストになる。</li>
</ul>
<hr>
<p><a id="a29"></a></p>
<h3 id="29章--クリーン組込みアーキテクチャ">29章  クリーン組込みアーキテクチャ</h3>
<ul>
<li>ファームウェア :
<ul>
<li>ハードウェアへの依存度合いの高いコードで書かれたソフトウェア。</li>
<li>例 : SQL埋め込みのコード。Android APIとビジネスロジックが分離できていないKotlinコード。</li>
<li>「ハードウェアに組み込まれたソフトウェア」のことではない。</li>
</ul>
</li>
<li>システムを長寿にするためには、ファームウェアの割合を低下させる。ビジネスロジックと分離する。</li>
<li>組み込みソフトウェア開発にも依存性のルールは適用可能。
<ul>
<li>ハードウェアに近いほどシステムの詳細。レイヤーの外側。</li>
</ul>
</li>
<li>組み込みにおけるレイヤー分割例 : ソフトウェア &lt;- OS &lt;- ファームウェア &lt;- ハードウェア</li>
</ul>
<hr>
<p><a id="a30"></a></p>
<h3 id="30章--データベースは詳細">30章  データベースは詳細</h3>
<ul>
<li>データアクセスのパフォーマンスは重要だが、やはりそれは下位レベルの関心事。アーキテクチャ全体にとっては些細。</li>
</ul>
<hr>
<p><a id="a31"></a></p>
<h3 id="31章--ウェブは詳細">31章  ウェブは詳細</h3>
<ul>
<li>ビジネスルールにとって、クライアント・サーバ方式か分散処理方式かといった問題は無関係。</li>
<li>ウェブはIOデバイスの一種。</li>
</ul>
<hr>
<p><a id="a32"></a></p>
<h3 id="32章--フレームワークは詳細">32章  フレームワークは詳細</h3>
<ul>
<li>フレームワークはアーキテクチャではない。</li>
<li>フレームワークの欠点 :
<ul>
<li>依存性ルールに違反する傾向にある。</li>
<li>レイヤーの内側と結合したがる。</li>
<li>仕様変更。</li>
<li>他のフレームワークへの乗り換えが難しい。</li>
</ul>
</li>
<li>フレームワークを使うときは、レイヤーの最下位レベルに配置する。</li>
</ul>
<hr>
<p><a id="a33"></a></p>
<h3 id="33章--事例動画販売サイト">33章  事例：動画販売サイト</h3>
<ul>
<li>最初のアーキテクチャを決める第一歩は、アクターとユースケースを分析・洗い出すこと。</li>
<li>次にコンポーネントの分析。
<ul>
<li>単一責任の原則にもとづくアクターによる分割。</li>
<li>依存性ルールによる分割。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="a34"></a></p>
<h3 id="34章--書き残したこと">34章  書き残したこと</h3>
<ul>
<li>この章だけ執筆者がSimon Brown氏。</li>
<li>安易なpublic化はカプセル化を台無しにし、設計が崩れる。</li>
</ul>
<hr>
<p><a id="a35"></a></p>
<h3 id="雑な感想">雑な感想</h3>
<ul>
<li>依存性逆転最高という感情が文章から溢れ出ている。</li>
<li>「システム」と「アプリケーション」の使い分けがようわからん。基本的に同一視してもいいか？</li>
<li>「コンポーネント」と「モジュール」の違いはわかる。前者はビルド・デプロイ単位で、後者は名前空間。よって、コンポーネントはモジュールを包含する。たぶん。</li>
<li>「サービス」ってなんだ？コンポーネントとどう違う？システムが提供する機能そのもの？これがわからないので27章を理解できなかった。</li>
<li>34章はさらにわからない。執筆者が違うためなのか、単におれが他のアーキテクチャについて知らなさすぎるためなのか。</li>
<li>最も頭が痛くなったのはまえがき。やたらと高尚な言い回しで出鼻をくじかれるので、初見ではスキップ推奨。
<ul>
<li>まえがきを書いてるのはKevlin Henney氏。C++方面で有名なコンサルらしいが、末端のおれからしたらんなこと知るか。</li>
</ul>
</li>
<li>DDDやTDDとどう関連するかは知らん。なぜならそれらの本を読んだことがないから。</li>
<li>GoFについて勉強する必要性を感じた。読みたい本が多くなりすぎて困る。本読む前にコード書いて試行錯誤するほうがいいんじゃないかという気持ちもあるし、みんなはどう折り合いをつけているのだろう。</li>
<li>関数型言語として取り上げられてるのが動的型付けのLispしかないのはちょっと気になる。おれ自身たいして詳しいわけではないが、静的型付けなら型クラスやトレイトで依存性逆転と似たようなことできそう。</li>
<li>そして無視される論理型言語。あわれなりProlog。</li>
<li>マーケティング部門をこきおろす文章に笑う。「マーケティングの奴らはいつも、ビジネスルールと UI を一体化したがるのだから」</li>
<li>24章で手抜き方法を紹介していることには少し驚いた。もっと原理主義的な本だと思っていたから。</li>
<li>結局、クリーンアーキテクチャって？ :  優れたアーキテクチャの最大公約数的なもの。Robert C.Martin氏が見出した共通点。</li>
</ul>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="https://guricerin.github.io/shit-blog/private-memo/20210906-std-linux/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">『ふつうのLinuxプログラミング 第2版』個人メモ</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="https://guricerin.github.io/shit-blog/private-memo/infra-engineer-text2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">『インフラエンジニアの教科書2』の個人メモ</p>
		</a>
	</div>
</nav>

<section class="comments">
	<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-guricerin-github-io-shit-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 guricerin.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="https://guricerin.github.io/shit-blog/js/menu.js"></script>
<script src="https://guricerin.github.io/shit-blog/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>