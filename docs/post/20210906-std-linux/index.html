<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>『ふつうのLinuxプログラミング 第2版』読んだ - グリのクソブログ</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="『ふつうのLinuxプログラミング 第2版』読んだ" />
<meta property="og:description" content="Linuxのことなんもわかってないので購入。本書はC言語プログラムを書くことを通してLinuxの仕組みを大雑把に学ぶという感じ。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guricerin.github.io/shit-blog/post/20210906-std-linux/" />
<meta property="article:published_time" content="2021-09-06T09:44:38+09:00" />
<meta property="article:modified_time" content="2021-09-06T09:44:38+09:00" />

		<meta itemprop="name" content="『ふつうのLinuxプログラミング 第2版』読んだ">
<meta itemprop="description" content="Linuxのことなんもわかってないので購入。本書はC言語プログラムを書くことを通してLinuxの仕組みを大雑把に学ぶという感じ。">
<meta itemprop="datePublished" content="2021-09-06T09:44:38&#43;09:00" />
<meta itemprop="dateModified" content="2021-09-06T09:44:38&#43;09:00" />
<meta itemprop="wordCount" content="620">



<meta itemprop="keywords" content="" />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="『ふつうのLinuxプログラミング 第2版』読んだ"/>
<meta name="twitter:description" content="Linuxのことなんもわかってないので購入。本書はC言語プログラムを書くことを通してLinuxの仕組みを大雑把に学ぶという感じ。"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="https://guricerin.github.io/shit-blog/css/style.css">
	<link rel="stylesheet" href="https://guricerin.github.io/shit-blog/css/custom.css">

	<link rel="shortcut icon" href="https://guricerin.github.io/shit-blog/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="https://guricerin.github.io/shit-blog/" title="グリのクソブログ" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="https://guricerin.github.io/shit-blog/img/icon.jpg">
				</div><div class="logo__item logo__text">
					<div class="logo__title">グリのクソブログ</div>
					<div class="logo__tagline">主にB&#39;z</div>
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">『ふつうのLinuxプログラミング 第2版』読んだ</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-06T09:44:38&#43;09:00">2021-09-06</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="https://guricerin.github.io/shit-blog/categories/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/" rel="category">プログラミング</a>, <a class="meta__link" href="https://guricerin.github.io/shit-blog/categories/%E6%9B%B8%E7%89%A9/" rel="category">書物</a>
	</span>
</div></div>
		</header>
		<div class="content post__content clearfix">
			<p>Linuxのことなんもわかってないので購入。本書はC言語プログラムを書くことを通してLinuxの仕組みを大雑把に学ぶという感じ。</p>
<p>公式ページ : <a href="https://www.sbcr.jp/product/4797386479/">https://www.sbcr.jp/product/4797386479/</a></p>
<p>環境は例によってWSL2のUbuntu 20.04を使用。以下、箇条書きの読書メモ。</p>
<h3 id="目次">目次</h3>
<ol>
<li><a href="#a1">Linuxプログラミングを始めよう</a></li>
<li><a href="#a2">Linuxカーネルの世界</a></li>
<li><a href="#a3">Linuxを描き出す3つの概念</a></li>
<li><a href="#a4">Linuxとユーザ</a></li>
<li><a href="#a5">ストリームにかかわるシステムコール</a></li>
<li><a href="#a6">ストリームにかかわるライブラリ関数</a></li>
<li><a href="#a7">headコマンドを作る</a></li>
<li><a href="#a8">grepコマンドを作る</a></li>
<li><a href="#a9">Linuxのディレクトリ構造</a></li>
<li><a href="#a10">ファイルシステムにかかわるAPI</a></li>
<li><a href="#a11">プロセスとハードウェア</a></li>
<li><a href="#a12">プロセスにかかわるAPI</a></li>
<li><a href="#a13">シグナルにかかわるAPI</a></li>
<li><a href="#a14">プロセスの環境</a></li>
<li><a href="#a15">ネットワークプログラミングの基礎</a></li>
<li><a href="#a16">HTTPサーバを作る</a></li>
<li><a href="#a17">HTTPサーバを本格化する</a></li>
<li><a href="#a18">本書を読み終えたあとは</a></li>
</ol>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="1章-linuxプログラミングを始めよう">1章 Linuxプログラミングを始めよう</h3>
<ul>
<li>gcc、コマンドライン引数、<code>man</code>コマンドの軽い解説。あまり使ったことないのは<code>man</code>ぐらい。</li>
<li>最初、<code>man 3 strlen</code>どころか<code>man strlen</code>すら<code>No manual entry for strlen</code>と返ってきて「なんでじゃ」と思いググったら、<code>sudo apt install -y manpages-dev manpages-posix-dev</code>であっさり解決した。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="2章-linuxカーネルの世界">2章 Linuxカーネルの世界</h3>
<ul>
<li>カーネル、システムコール、ライブラリなどの軽い解説。ぶっちゃけみかん本で学びたての内容。</li>
<li>Win32 APIがなぜかシステムコールonlyの概念だと誤解されたことによって、APIとシステムコールをごっちゃにしている人が多いっていう話は初めて知った。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="3章-linuxを描き出す3つの概念">3章 Linuxを描き出す3つの概念</h3>
<ul>
<li>ファイルシステム、プロセス、ストリームについて。</li>
<li>ファイル : バイト列を格納するオブジェクト。</li>
<li><code>/dev/null</code>は読み込むと常に空、書き込むとどこかに消えるファイル</li>
<li><code>mount</code>コマンドでデバイスファイルとそのファイルシステムの一覧を得られるのは知らなかった。みかん本で解説あったっけ？</li>
<li>プロセス : 実行中のプログラム。1つのプログラムから複数のプロセスを作成可能。
<ul>
<li>タスクとプロセスの違いは文脈による？どうやらタスクのほうが用語としては曖昧そうなので、プロセスを使ったほうがいいかも。</li>
</ul>
</li>
<li>各プロセスには一意のプロセスIDが割り当てられる。</li>
<li>ストリーム : バイト列の通り道。ファイルディスクリプタで表現される。他書籍では単にファイル（とくにFILE型）のことを指したりする。</li>
<li>パイプ : 両端にプロセスがつながっているストリーム。</li>
<li>プロセス間通信 : プロセス同士がストリームを通じてデータをやり取りすること。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="4章-linuxとユーザ">4章 Linuxとユーザ</h3>
<ul>
<li>グループ : グループに対して権限を与えると、それに属するユーザにも権限を与えたことになる。</li>
<li>パーミッション : ファイルのアクセス権。
<ul>
<li>ファイルを所有するユーザ、ファイルを所有するグループに属するユーザ、それ以外のユーザについて別々に設定する。</li>
<li>権限は読み込み、書き込み、実行の3種。</li>
<li>3つのユーザ区分 * 3種の権限で、9つの設定可能項目がある。</li>
<li>ex. ファイル属性が「lrwxr-xr-x」 : ディレクトリではない狭義のファイル。ファイル所有ユーザはすべてのアクセス権限をもつが、ファイル所有グループ、その他のユーザは書き込みのみ不可能（755）。</li>
</ul>
</li>
<li>ディレクトリが実行不可能の場合、その中のファイルへの読み書き実行すべてのアクセスが、そのファイルのパーミッションには関係なく不可能となる。</li>
<li>クレデンシャル : プロセスの属性としてのユーザ。プロセスを実行しているユーザのユーザID。</li>
<li>ユーザデータベース :
<ul>
<li>ユーザ名とユーザIDの対応表は、通常<code>/etc/passwd</code>に記載されている。</li>
<li>グループ名とグループIDの対応表は、通常<code>/etc/group</code>に記載されている。</li>
<li>ユーザデータベースへのアクセスには専用のAPIを使う。</li>
</ul>
</li>
</ul>
<hr>
<p>&lt;a id=&quot;a5&gt;<!-- raw HTML omitted --></p>
<h3 id="5章-ストリームにかかわるシステムコール">5章 ストリームにかかわるシステムコール</h3>
<ul>
<li>プロセスからストリームにアクセスするには、そのストリームに対応したファイルディスクリプタという整数値を指定する。</li>
<li>標準入出力の「標準」は「デフォルトの」と読み替えるとわかりやすい。</li>
<li>Linuxコマンドは標準入力から読み込み標準出力に書き込むことを前提にしているので、パイプやリダイレクトによる連携が容易。</li>
<li>標準エラー出力は人間向け。</li>
<li>C言語のAPIはNULL文字を前提とするものとしないものが混在しているので注意（いやすぎる）。</li>
<li>ファイルオフセット : ストリームがつながっている、ファイルのバイト位置（ストリームはファイルそのものにつながっているわけではない）。</li>
</ul>
<hr>
<p>&lt;a id=&quot;a6&gt;<!-- raw HTML omitted --></p>
<h3 id="6章-ストリームにかかわるライブラリ関数">6章 ストリームにかかわるライブラリ関数</h3>
<ul>
<li>読み書きのライブラリ関数はバッファリングを行うため、少しずつの読み書きでも呼び出しの遅いシステムコールと比べると速い。</li>
<li>書き込み先が端末の場合（改行文字が来るごとに出力）や、標準エラー出力の場合はバッファリングを行わない。</li>
<li>FILE型は生のストリームにバッファリングを追加している型。</li>
<li><code>flush</code> : バッファリングしている内容を即座にwriteすること。</li>
<li><code>strace</code> : プロセスが呼んだシステムコールを表示するコマンド。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="7章-headコマンドを作る">7章 headコマンドを作る</h3>
<ul>
<li>コマンドラインオプションを簡単にパース可能な<code>getopt</code>ライブラリを導入。
<ul>
<li>Rustの<a href="https://github.com/clap-rs/clap">Clap</a>ってこれが元ネタか。</li>
</ul>
</li>
<li>デバッガとして<code>gdb</code>を使用する。
<ul>
<li>デバッグ対象のプログラムは<code>-g</code>オプションでビルドする必要あり。</li>
</ul>
</li>
<li><code>gdb [PROGRAM]</code> : PROGRAMをデバッグ開始。</li>
<li><code>run [ARGS]</code> : デバッグ対象のプログラムにコマンドライン引数を渡して起動させる。</li>
<li><code>backtrace</code> : 現在実行中の関数を、呼び出し順の逆に列挙。</li>
<li><code>frame [NUMBER]</code> : 指定フレーム番号の関数に移動し、実行中のコードの行を表示。</li>
<li><code>list</code> : 実行中コードとその前後数行を表示。</li>
<li><code>print [SYMBOL]</code> : 指定シンボルの中身を表示。変数ならその値。関数なら引数・戻り値の型、関数が配置されたメモリアドレス。</li>
<li><code>quit</code> : gdbを終了。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="8章-grepコマンドを作る">8章 grepコマンドを作る</h3>
<ul>
<li>grepコマンドの作成を通して、正規表現について学習。</li>
<li>正規表現ライブラリは<code>regex</code>を使用。</li>
<li>文字エンコードについても少し触れる。</li>
<li>符号化文字集合 : 文字エンコードで扱える文字の範囲。</li>
<li>ワイドキャラクタ : すべての文字に対して同じバイト数を割り当てるエンコーディング。</li>
<li>マルチバイトキャラクタ : 文字の種類によって割り当てるバイト数を変えるエンコーディング。</li>
<li>本書ではUTF-16は2バイトのワイドキャラクタって記載されてるけど、<a href="https://ja.wikipedia.org/wiki/UTF-16">2 or 4バイトのマルチバイトキャラクタじゃね？</a>。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="9章-linuxのディレクトリ構造">9章 Linuxのディレクトリ構造</h3>
<ul>
<li>FHS (The Filesystem Hierarchy Standard) : ディレクトリツリーの標準規格</li>
<li><code>/bin</code> : カーネルをブートするときに必要なシステムの基本コマンド。最近は<code>/usr/bin</code>へのシンボリックリンクになっている。
<ul>
<li><code>/usr/bin</code> : 一般ユーザ向けのコマンド。</li>
</ul>
</li>
<li><code>/sbin</code> : 管理者用コマンド。
<ul>
<li><code>/usr/sbin</code> : 平時用のシステム管理コマンドやサーバプログラム。</li>
</ul>
</li>
<li><code>/lib</code>, <code>/lib64</code>など : ライブラリ（libxxx.so, libxxx.a）。</li>
<li><code>/usr</code> : 別のマシンからネットワークごしにマウントすることを想定したディレクトリ（別マシンに同じファイルをいくつもコピーするのはめんどいため）。</li>
<li><code>/usr/src</code> : システムで使っているコマンドのソースコードやカーネルのソースコード。</li>
<li><code>/usr/include</code> : システムのヘッダファイル。</li>
<li><code>/usr/shere</code> : アーキテクチャ（CPUの種類）に依存しない、共有可能なファイル（ドキュメントなど）。</li>
<li><code>/usr/local</code> : <code>/usr</code>直下と同じような感じ。<code>/usr</code>直下はディストリビューションが管理し、<code>/usr/local</code>はシステム管理者が管理する。</li>
<li><code>/var</code> : 頻繁に書き換えられるファイルのディレクトリ。</li>
<li><code>/var/log</code> : 主にサーバプロセスが書き込むログファイル。</li>
<li><code>/var/spool</code> : ユーザのメールやプリンタの入力などを一時的に保存。</li>
<li><code>/var/run</code> : 起動中のサーバプロセスのプロセスID（PIDファイル）を保存。<code>/run</code>へのシンボリックリンク。</li>
<li><code>/etc</code> : 各マシンごとの設定ファイル。</li>
<li><code>/dev</code> : デバイスファイル。</li>
<li><code>/proc</code> : procfs（プロセスファイルシステム）がマウントされている。カーネルの情報をリアルタイムに出力する仕組みとしても使われる。</li>
<li><code>/sys</code> : sysfsがマウントされている。デバイスやデバイスドライバの情報を得られる。</li>
<li><code>/boot</code> : カーネルのプログラム。</li>
<li><code>/root</code> : スーパーユーザのホームディレクトリ。</li>
<li><code>/tmp</code> : 一時ファイル用。リブートしたら削除される可能性がある。</li>
<li><code>/var/tmp</code> : 一時ファイル用。リブートしても削除されない。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="10章-ファイルシステムにかかわるapi">10章 ファイルシステムにかかわるAPI</h3>
<ul>
<li>ls, mkdir, rmdir, ln, symlink, rm, mv, stat, chmodコマンドを作成。</li>
<li>ディレクトリにつながるストリームは、ファイル1つの情報を表す構造体の列になる。</li>
<li>ディレクトリツリーを一発で作成するシステムコールは存在しないので、<code>mkdir -p &lt;PATH&gt;</code>は<code>mkdir</code>システムコールを地道に繰り返し呼んでいる。</li>
<li>同様にディレクトリの中身を全部消すシステムコールも存在しないので、<code>rm -r &lt;PATH&gt;</code>は中身を1つずつ削除している。</li>
<li>ハードリンク
<ul>
<li><code>ln &lt;SRC&gt; &lt;DEST&gt;</code></li>
<li>ファイルに別名を与える（ファイル実態のリンクカウントが1増える）。</li>
<li><code>rm</code>が行うのはファイル削除ではなくファイル名の削除。ファイル実態はリンクカウントが0になってはじめて削除される。</li>
<li>ディレクトリのハードリンクは作成不可。</li>
<li>dotfilesの文化を知って「おれも作っちゃうぞ」となったとき、シンボリックリンクとハードリンクの区別がまだついてなくてホームディレクトリがハチャメチャになったことを思い出した。</li>
</ul>
</li>
<li>シンボリックリンク
<ul>
<li><code>ln -s &lt;SRC&gt; &lt;DEST&gt;</code></li>
<li>対応するファイル実態が存在しなくてもよい（ファイル実態にアクセスするときに名前と実態の対応付けを行うため）。</li>
<li>ファイルシステムをまたげる。</li>
<li>ディレクトリのシンボリックリンクなら作成可能。</li>
</ul>
</li>
<li>ファイルの移動は、厳密にはファイル名の変更。</li>
<li><code>stat &lt;FILE PATH&gt;</code> : ファイルの付帯情報を得るコマンド。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="11章-プロセスとハードウェア">11章 プロセスとハードウェア</h3>
<ul>
<li>マルチプロセスや仮想メモリについて。</li>
<li>仮想メモリあたりはみかん本で習いたてなのですんなり頭に入ってきた。</li>
<li>タイムスライス（time slice）: 各プロセスに配分されるCPU時間。</li>
<li>スケジューラ（scheduler）: プロセスにいつタイムスライスを与えるかを管理するカーネルの機構。ディスパッチャ（dispatcher）とも。</li>
<li>ページング
<ul>
<li>物理メモリが枯渇したら、あまり使われていないページをストレージに退避し、論理アドレスとの対応を解除。</li>
<li>プロセスがそのページにアクセスしたら、ストレージから該当ページをロードし、論理アドレスに対応させてプロセスを再開。</li>
</ul>
</li>
<li>スワッピング : ページングがページ単位での操作なのに対し、スワッピングはプロセス全体を単位にした操作。</li>
<li>プロセスのアドレス空間の構造
<ul>
<li>text領域 : 機械語プログラム。</li>
<li>data領域 : グローバル変数、初期化済みのスタティック変数、文字列リテラル。</li>
<li>BSS領域 : グローバル変数、初期化が不必要なスタティック変数。</li>
<li>heap領域 : <code>malloc()</code>が管理する。実行時に拡大・縮小する可能性あり。</li>
<li>stack領域 : 関数呼び出しに伴って必要になるデータ。引数やローカル変数。</li>
</ul>
</li>
<li><code>/proc/&lt;PID&gt;/maps</code> : 該当PIDのプロセスのアドレス空間が記載されている。</li>
<li>C言語のビルド
<ul>
<li>プリプロセス
<ul>
<li><code>#include</code>や<code>#define</code>を処理したソースコードを出力。</li>
<li><code>gcc -E</code>でプリプロセスまでの処理結果を標準出力に出力。</li>
</ul>
</li>
<li>コンパイル
<ul>
<li>C言語ソースコードをアセンブリ言語（*.s）に変換。</li>
<li><code>gcc -S</code>でコンパイルまでの処理結果をファイル出力。</li>
</ul>
</li>
<li>アセンブル
<ul>
<li>アセンブリ言語ソースコードを機械語を含むオブジェクトファイル（*.o）に変換。</li>
<li>フォーマットはELF形式。</li>
<li><code>gcc -c</code>でアセンブルまでの処理結果をファイル出力。</li>
</ul>
</li>
<li>リンク
<ul>
<li>オブジェクトファイル（<em>.o）から実行ファイル（拡張子なし）or ライブラリ（</em>.a, *.so）を生成。</li>
<li>実行ファイルのフォーマットはELF形式。</li>
</ul>
</li>
</ul>
</li>
<li>スタティックリンク
<ul>
<li>必要な関数がビルド時に静的ライブラリから取り出され、生成するオブジェクトファイルに連結される。</li>
<li>静的ライブラリの拡張子は通常<code>*.a</code>。</li>
</ul>
</li>
<li>ダイナミックリンク
<ul>
<li>必要な関数がビルド時に共有ライブラリに含まれるかチェック。</li>
<li>共有ライブラリの拡張子は通常<code>*.so</code>。</li>
<li>プログラム起動時、リンクローダ（link loader）が実行ファイルと共有ライブラリにメモリに展開し、メモリ上でコードを結合。</li>
</ul>
</li>
<li>スタティックリンクはほとんど使われない。</li>
<li>ダイナミックロード
<ul>
<li>ビルド時の関数チェックすら行わない。</li>
<li>プログラム実行中に、プロセスのメモリ空間にいるリンクローダをもう一度動かすことでコードを結合。</li>
</ul>
</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="12章-プロセスにかかわるapi">12章 プロセスにかかわるAPI</h3>
<ul>
<li><code>fork()</code>
<ul>
<li>自プロセスが複製される。ストリームもすべて複製される。</li>
<li>2つのプロセスの両方に<code>fork()</code>の呼び出しが戻り、両方のプロセスで<code>fork()</code>以降のコードが実行される。</li>
</ul>
</li>
<li><code>exec()</code>
<ul>
<li>自プロセスを新しいプログラムで上書きする。それまで実行していたプログラムは消滅。</li>
<li>成功すると呼び出しは戻らない。</li>
<li><code>fork()</code>して即座に<code>exec()</code>することで新たなプログラムを実行したことになる。</li>
</ul>
</li>
<li><code>wait()</code>
<ul>
<li><code>fork()</code>した子プロセスのうちどれか1つが終了するのを待機。</li>
</ul>
</li>
<li><code>exit()</code>
<ul>
<li>指定ステータスを終了ステータスとして自プロセスを終了。</li>
</ul>
</li>
<li>ゾンビプロセス（zombie processs）
<ul>
<li>親プロセスがwait()しないままでいる子プロセス。</li>
<li>親プロセスが終了するかwait()を呼ぶまでは、ゾンビプロセスのステータスコードをカーネルが保持し続けるので、カーネルの負担が増える。</li>
</ul>
</li>
<li>パイプ
<ul>
<li>プロセスからプロセスにつながったストリーム。</li>
<li>やはりファイルディスクリプタで表現される。</li>
<li>読むか書くかの片方しか無理。</li>
</ul>
</li>
<li><code>pipe()</code>
<ul>
<li>両端とも自プロセスにつながったストリームを作成。</li>
<li><code>pipe()</code>後に<code>fork()</code>し、親が読み込み側を<code>close()</code>、子が書き込み側を<code>close()</code>することで親子間にパイプを作成できる。</li>
</ul>
</li>
<li><code>systemd</code>
<ul>
<li>ブート時にカーネルが直接起動するプログラム</li>
<li>すべてのプロセスの祖先。PIDは1。</li>
<li>旧くは<code>init</code>。</li>
</ul>
</li>
<li>自プロセスと直接の親子関係にあるプロセス情報はAPIで取得可能。その他のプロセスについては<code>/proc</code>以下を調べるほかない。</li>
<li><code>pstree</code> : プロセスの親子関係を表す木構造を調べる。</li>
<li>プロセスグループ
<ul>
<li>パイプでつながれたプロセス群。</li>
<li>パイプで起動したプロセス群を<code>Ctrl + C</code>などで一斉に停止するために考案された機能。</li>
</ul>
</li>
<li>セッション
<ul>
<li>ユーザのログインからログアウトまでの流れを管理するための概念。</li>
<li>ログインシェルを起点に、ユーザが同じ端末から起動したプロセスをまとめる機能。</li>
<li>1つのセッションは複数のプロセスグループをまとめる。</li>
<li>プロセスの制御端末（controlling terminal） : セッションと関連付けられた端末。</li>
</ul>
</li>
<li><code>ps j</code> : プロセスグループやセッションを調べる。</li>
<li>デーモンプロセス（daemon process）
<ul>
<li>制御端末をもたないプロセス。</li>
<li>制御端末をもつプロセスは、そのプロセスを起動したユーザがログアウトすると停止される。</li>
<li>サーバ用途。</li>
</ul>
</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="13章-シグナルにかかわるapi">13章 シグナルにかかわるAPI</h3>
<ul>
<li>シグナル
<ul>
<li>ユーザ（端末）やカーネルがプロセスに何かを通知する目的で使用されるデータ。int型の整数。</li>
<li>ソフトウェア割り込みのこと（参考 : <a href="http://www.coins.tsukuba.ac.jp/~yas/coins/syspro-2000/2000-05-01/process-signal.html">http://www.coins.tsukuba.ac.jp/~yas/coins/syspro-2000/2000-05-01/process-signal.html</a>）。</li>
</ul>
</li>
<li>シグナルを受けたプロセスの処理
<ul>
<li>無視する。</li>
<li>プロセスを終了する。</li>
<li>プロセスのコアダンプを作成して異常終了する。</li>
</ul>
</li>
<li>コアダンプ（core dump）: プロセスのメモリのスナップショット。</li>
<li>SIGKILL
<ul>
<li>プロセスを強制終了するための、カーネルに用意された最終手段となるシグナル。</li>
<li>プロセスからは補足不可。</li>
</ul>
</li>
<li>シグナルの補足（catch, trap）
<ul>
<li>シグナルの処理をカーネル任せにせず、自プロセスで行うこと。</li>
<li>あるシグナルに対する独自のシグナルハンドラ（signal handler）を登録するシステムコールがある。</li>
<li><code>signal()</code>は問題だらけなので<code>sigaction()</code>を使うのが主流。</li>
</ul>
</li>
<li><code>kill()</code> : 指定PIDのプロセスに対して指定シグナルを送信。名前がややこしい。</li>
<li><code>stty -a</code> : 端末上でどの特殊キーがどんな働きをするかを調べる。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="14章-プロセスの環境">14章 プロセスの環境</h3>
<ul>
<li><code>getcwd()</code> : 自プロセスのカレントディレクトリを取得。</li>
<li><code>chdir()</code> : 自プロセスのカレントディレクトリを変更。</li>
<li><code>/proc/&lt;PID&gt;/cwd</code> : 指定プロセスのカレントディレクトリを取得。他プロセスからの変更は不可。</li>
<li>環境変数（environment variable）
<ul>
<li>プロセスの親子関係を通じて伝播するパラメータ。</li>
<li>プロセス毎に保持・管理される。</li>
</ul>
</li>
<li><code>environ</code> : 自プロセスの環境変数を保持するグローバル変数。型は<code>char**</code>。</li>
<li><code>getenv()</code> : 指定の環境変数の値を取得。</li>
<li><code>putenv()</code> : 環境変数を設定。引数は<code>&lt;name&gt;=&lt;value&gt;</code>の形式でなければならない。</li>
<li>set-uidプログラム
<ul>
<li>set-uidビットが立っている（ファイルの実行権限が通常<code>x</code>なのに対し、<code>s</code>になっている）プログラム。</li>
<li>コマンドの実行ユーザに関係なく、そのコマンドの所有者の権限で起動される（権限の自動昇格）。</li>
<li>このときのクレデンシャルは2種類。
<ul>
<li>実ユーザID（real user ID）: コマンドを実行したユーザのID。</li>
<li>実効ユーザID（effective user ID）: コマンドの所有ユーザID。</li>
</ul>
</li>
</ul>
</li>
<li>set-gidプログラム : set-uidプログラムのグループ版。その他の仕組みなどもほぼ一緒。</li>
<li>自プロセスの現在のクレデンシャルを取得・変更するシステムコールあり。</li>
<li><code>getrusage()</code> : 自プロセスの使用リソース（CPUの使用時間、メモリ使用量など）を取得。</li>
<li>システム時間（system time）: 自プロセスのためにカーネルに働かせた時間。</li>
<li>ユーザ時間（user time）: システム時間以外の消費時間。</li>
<li>メジャーフォールト（major fault）: ページフォールトに対して物理ページの割り当てが起こった回数のうち、ストレージとの入出力が伴うもの。</li>
<li>マイナーフォールト（minor fault）: ストレージとの入出力が伴わないもの。</li>
<li>UNIXエポック（UNIX epoch）
<ul>
<li>1970年1月1日午前0時。</li>
<li>Linuxカーネルは時刻をUNIXエポックからの経過秒数で保持。</li>
<li>協定世界時（UTC : Coordinated Universal Time）で計算。</li>
</ul>
</li>
<li>ログインの流れ
<ul>
<li><code>systemd</code> or <code>init</code>が端末の数だけ<code>getty</code>コマンドを起動。</li>
<li><code>getty</code>コマンドはユーザ名が入力されるのを待ち端末の設定を行って、<code>login</code>コマンドを起動。</li>
<li><code>login</code>コマンドはユーザを認証。</li>
<li>シェルを起動。</li>
</ul>
</li>
<li>PAM（Pluggable Authentication Module）
<ul>
<li>ユーザデータベースの配置場所、パスワードの種類、ログイン可能な時間・ユーザなどの設定を隠蔽するためのAPIを搭載。</li>
<li><code>login</code>やssh、ftpなどのユーザ認証を担う。</li>
</ul>
</li>
<li>シェルを起動するときに頭に<code>-</code>をつけるとログインシェルとなる。
<ul>
<li>ex. <code>-sh</code>, <code>-bash</code></li>
</ul>
</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="15章-ネットワークプログラミングの基礎">15章 ネットワークプログラミングの基礎</h3>
<ul>
<li>インターネットにつながるホスト（コンピュータ、ノード）には必ず1つ以上のIPアドレスが割り当てられる。</li>
<li><code>/etc/services</code> : 一般的なウェルノウンポートを列挙している。</li>
<li>TCPはパケットを通し番号順にソートし、データをストリームであるかのように上の層に見せかける。</li>
<li>リゾルバ（resolver）: コンピュータの世界における、名前から実態を取得する機構。</li>
<li>ソケット : ネットワーク通信によるストリームを接続する入り口。ファイルディスクリプタで表現される。</li>
<li><code>socket()</code> : ソケットを作成。サーバ・クライアントの両方で使用。</li>
<li><code>connect()</code> : ソケットを指定アドレス・指定ポート番号のサーバに接続。クライアント用。</li>
<li><code>bind()</code> : 指定アドレス・指定ポート番号をソケットに割り当てる。サーバ用。</li>
<li><code>listen()</code> : 指定ソケットが接続待ち用であることをカーネルに伝える。サーバ用。</li>
<li><code>accept()</code> : 指定ソケットにクライアントが接続してくるのを待ち、接続が完了したら接続済みストリームのファイルディスクリプタを返す。サーバ用。</li>
<li><code>getaddrinfo()</code> : ホスト名・サービス名からIPアドレス・ポート番号を取得。</li>
<li><code>daytime</code>
<ul>
<li>テスト用のプロトコル。</li>
<li>ソケットで接続するとサーバが時刻を文字列で返す。</li>
</ul>
</li>
<li>インターネットスーパーサーバ（internet super server）
<ul>
<li>ネットワーク接続部分だけを引き受けるサーバ。</li>
<li>待受ポートを監視し、クライアントから接続されたら該当サーバプロセスを起動する。</li>
<li>ソケットを標準入出力に移すことで、該当サーバプロセスは標準入出力経由でネットワーク通信可能。</li>
<li>inetd,、xinetd（inetdのセキュリティ改良版）。</li>
</ul>
</li>
<li>WSL2のUbuntuの場合、先祖プロセスはsystemdではなくカスタムされたinitなので、デーモンの再起動は<code>sudo systemctl reload xinetd</code>ではなく<code>sudo service xinetd restart</code>。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="16章-httpサーバを作る">16章 HTTPサーバを作る</h3>
<ul>
<li>指定URLのファイルの中身を表示するHTTPサーバを作成。
<ul>
<li>現時点では標準入出力を端末につないだままでやり取りする。</li>
</ul>
</li>
<li>ドキュメントツリー（document tree）: HTTPサーバのファイルシステムのうち、HTTPで公開される部分。</li>
<li>ドキュメントルート（document root）: ドキュメントツリーのルートディレクトリ。</li>
<li>パスの正規化（canonicalize）: 相対パスやシンボリックリンクを絶対パスに解決すること。パスの安全性を確かめるのに必要。</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="17章-httpサーバを本格化する">17章 HTTPサーバを本格化する</h3>
<ul>
<li>前章のサーバをソケットを読み書きするよう改造。</li>
<li>サーバプロセスをサーバ足らしめるには、<code>accept()</code>を何度も呼ぶ必要がある。</li>
<li>IPv4とIPv6の接続を同時に待機するには<code>select()</code>を使う。</li>
<li>意図せぬエラー防止のため、デーモンプログラムは標準入出力を切っておくのがベター。</li>
<li>並行サーバ（concurrent server） :
<ul>
<li>親プロセスは<code>accept()</code>し続ける。</li>
<li><code>accept()</code>した後に<code>fork()</code>する。</li>
<li>子プロセスでリクエストを処理する。</li>
<li>たいていのサーバはこれ。</li>
</ul>
</li>
<li>プリフォークサーバ（prefork server）:
<ul>
<li>親プロセスが最初に何回か<code>fork()</code>してから、子プロセスで<code>accept()</code>する。</li>
<li>パフォーマンスは良いが、実装も運用も難易度が高い。</li>
</ul>
</li>
<li><code>syslog</code> : UNIXのロギングAPI。</li>
<li><code>chroot()</code> :
<ul>
<li>自プロセスのルートディレクトリを指定パスに変更。
-ドキュメントツリーの範囲外が公開されるのを防ぐなど、ファイルシステムの安全性のためにつかう。</li>
<li>分離するのはファイルシステムだけ。その他のCPUやメモリなどのリソースは分離できないので、無限ループなどに入ると外側のプロセスに影響を与える。</li>
</ul>
</li>
<li>cgroups（control groups）:
<ul>
<li>プロセスグループのリソースを分離する。カーネルの機能。</li>
<li>Linuxの中に独立した環境を作成可能。</li>
<li>階層型。</li>
<li>コンテナ（container）: 独立した環境のこと。</li>
</ul>
</li>
</ul>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="18章-本書を読み終えたあとは">18章 本書を読み終えたあとは</h3>
<ul>
<li>X Window System :
<ul>
<li>モニタに画像を出力するシステム。クライアント・サーバモデル。</li>
<li>X protocol : X server（画面出力）とX client（アプリ）がソケット通信する際に用いるプロトコル。</li>
</ul>
</li>
<li>Curses : 端末制御用のライブラリ。</li>
</ul>
<hr>
<h3 id="まとめ">まとめ</h3>
<p>どう考えてもみかん本より先に呼んでおくべきだった本だが、まあええか。</p>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="https://guricerin.github.io/shit-blog/post/20210905-beauty/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">美醜</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="https://guricerin.github.io/shit-blog/post/20210916-clean-arch/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">『Clean Architecture 達人に学ぶソフトウェアの構造と設計』読んだ</p>
		</a>
	</div>
</nav>

<section class="comments">
	<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-guricerin-github-io-shit-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 guricerin.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="https://guricerin.github.io/shit-blog/js/menu.js"></script>
<script src="https://guricerin.github.io/shit-blog/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>